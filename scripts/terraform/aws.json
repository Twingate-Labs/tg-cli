{
  "main": "# ------------------------------------------------------------------------------\n# Resources\n# ------------------------------------------------------------------------------\ndata \"aws_availability_zones\" \"main\" {}\n\ndata \"aws_region\" \"current\" {}\n\nlocals {\n  azs               = length(var.availability_zones) > 0 ? var.availability_zones : data.aws_availability_zones.main.names\n  nat_gateway_count = var.create_nat_gateways ? min(length(local.azs), length(var.public_subnet_cidrs), length(var.private_subnet_cidrs)) : 0\n\n  internet_gateway_count             = (var.create_internet_gateway && length(var.public_subnet_cidrs) > 0) ? 1 : 0\n  egress_only_internet_gateway_count = (var.create_egress_only_internet_gateway && length(var.private_subnet_cidrs) > 0) ? 1 : 0\n}\n\nresource \"aws_vpc\" \"main\" {\n  cidr_block                       = var.cidr_block\n  instance_tenancy                 = \"default\"\n  enable_dns_support               = true\n  enable_dns_hostnames             = var.enable_dns_hostnames\n  assign_generated_ipv6_cidr_block = true\n\n  tags = merge(\n    var.tags,\n    {\n      \"Name\" = \"${var.name_prefix}-vpc\"\n    },\n  )\n}\n\nresource \"aws_internet_gateway\" \"public\" {\n  count      = local.internet_gateway_count\n  depends_on = [aws_vpc.main]\n  vpc_id     = aws_vpc.main.id\n\n  tags = merge(\n    var.tags,\n    {\n      \"Name\" = \"${var.name_prefix}-public-igw\"\n    },\n  )\n}\n\nresource \"aws_egress_only_internet_gateway\" \"outbound\" {\n  count      = local.egress_only_internet_gateway_count\n  depends_on = [aws_vpc.main]\n  vpc_id     = aws_vpc.main.id\n}\n\nresource \"aws_route_table\" \"public\" {\n  count      = length(var.public_subnet_cidrs) > 0 ? 1 : 0\n  depends_on = [aws_vpc.main]\n  vpc_id     = aws_vpc.main.id\n\n  tags = merge(\n    var.tags,\n    {\n      \"Name\" = \"${var.name_prefix}-public-rt\"\n    },\n  )\n}\n\nresource \"aws_route\" \"public\" {\n  count = local.internet_gateway_count\n  depends_on = [\n    aws_internet_gateway.public,\n    aws_route_table.public,\n  ]\n  route_table_id         = aws_route_table.public[0].id\n  gateway_id             = aws_internet_gateway.public[0].id\n  destination_cidr_block = \"0.0.0.0/0\"\n}\n\nresource \"aws_route\" \"ipv6-public\" {\n  count = local.internet_gateway_count\n  depends_on = [\n    aws_internet_gateway.public,\n    aws_route_table.public,\n  ]\n  route_table_id              = aws_route_table.public[0].id\n  gateway_id                  = aws_internet_gateway.public[0].id\n  destination_ipv6_cidr_block = \"::/0\"\n}\n\nresource \"aws_subnet\" \"public\" {\n  count                           = length(var.public_subnet_cidrs)\n  vpc_id                          = aws_vpc.main.id\n  cidr_block                      = var.public_subnet_cidrs[count.index]\n  ipv6_cidr_block                 = cidrsubnet(aws_vpc.main.ipv6_cidr_block, 8, var.ipv6_public_subnet_netnum_offset + count.index)\n  availability_zone               = element(local.azs, count.index)\n  map_public_ip_on_launch         = var.map_public_ip_on_launch\n  assign_ipv6_address_on_creation = true\n\n  tags = merge(\n    var.tags,\n    {\n      \"Name\" = \"${var.name_prefix}-public-subnet-${count.index + 1}\"\n      \"Tier\" = \"Public\"\n    },\n  )\n}\n\nresource \"aws_route_table_association\" \"public\" {\n  count          = length(var.public_subnet_cidrs)\n  subnet_id      = aws_subnet.public[count.index].id\n  route_table_id = aws_route_table.public[0].id\n}\n\nresource \"aws_eip\" \"private\" {\n  count = local.nat_gateway_count\n\n  tags = merge(\n    var.tags,\n    {\n      \"Name\" = \"${var.name_prefix}-nat-gateway-${count.index + 1}\"\n    },\n  )\n}\n\nresource \"aws_nat_gateway\" \"private\" {\n  depends_on = [\n    aws_internet_gateway.public,\n    aws_eip.private,\n  ]\n  count         = local.nat_gateway_count\n  allocation_id = aws_eip.private[count.index].id\n  subnet_id     = element(aws_subnet.public[*].id, count.index)\n\n  tags = merge(\n    var.tags,\n    {\n      \"Name\" = \"${var.name_prefix}-nat-gateway-${count.index + 1}\"\n    },\n  )\n}\n\nresource \"aws_route_table\" \"private\" {\n  depends_on = [aws_vpc.main]\n  count      = length(var.private_subnet_cidrs)\n  vpc_id     = aws_vpc.main.id\n\n  tags = merge(\n    var.tags,\n    {\n      \"Name\" = \"${var.name_prefix}-private-rt-${count.index + 1}\"\n    },\n  )\n}\n\nresource \"aws_route\" \"private\" {\n  depends_on = [\n    aws_nat_gateway.private,\n    aws_route_table.private,\n  ]\n  count                  = local.nat_gateway_count > 0 ? length(var.private_subnet_cidrs) : 0\n  route_table_id         = aws_route_table.private[count.index].id\n  nat_gateway_id         = element(aws_nat_gateway.private[*].id, count.index)\n  destination_cidr_block = \"0.0.0.0/0\"\n}\n\nresource \"aws_route\" \"ipv6-private\" {\n  depends_on = [\n    aws_egress_only_internet_gateway.outbound,\n    aws_route_table.private,\n  ]\n  count                       = length(var.private_subnet_cidrs) > 0 && local.egress_only_internet_gateway_count > 0 ? length(var.private_subnet_cidrs) : 0\n  route_table_id              = aws_route_table.private[count.index].id\n  egress_only_gateway_id      = aws_egress_only_internet_gateway.outbound[0].id\n  destination_ipv6_cidr_block = \"::/0\"\n}\n\nresource \"aws_subnet\" \"private\" {\n  count                           = length(var.private_subnet_cidrs)\n  vpc_id                          = aws_vpc.main.id\n  cidr_block                      = var.private_subnet_cidrs[count.index]\n  ipv6_cidr_block                 = cidrsubnet(aws_vpc.main.ipv6_cidr_block, 8, count.index + (var.ipv6_private_subnet_netnum_offset == -1 ? length(var.public_subnet_cidrs) : var.ipv6_private_subnet_netnum_offset))\n  availability_zone               = element(local.azs, count.index)\n  map_public_ip_on_launch         = false\n  assign_ipv6_address_on_creation = true\n\n  tags = merge(\n    var.tags,\n    {\n      \"Name\" = \"${var.name_prefix}-private-subnet-${count.index + 1}\"\n      \"Tier\" = \"Private\"\n    },\n  )\n}\n\nresource \"aws_route_table_association\" \"private\" {\n  count          = length(var.private_subnet_cidrs)\n  subnet_id      = aws_subnet.private[count.index].id\n  route_table_id = aws_route_table.private[count.index].id\n}\n\nresource \"aws_vpc_endpoint\" \"s3\" {\n  count           = var.enable_vpc_endpoints ? 1 : 0\n  service_name    = \"com.amazonaws.${data.aws_region.current.name}.s3\"\n  vpc_id          = aws_vpc.main.id\n  route_table_ids = compact(concat(aws_route_table.private.*.id, aws_route_table.public.*.id))\n  policy          = var.s3_endpoint_policy\n  tags = merge(\n    var.tags,\n    {\n      \"Name\" = \"${var.name_prefix}-s3\"\n    },\n  )\n}\n\nresource \"aws_vpc_endpoint\" \"dynamodb\" {\n  count           = var.enable_vpc_endpoints ? 1 : 0\n  service_name    = \"com.amazonaws.${data.aws_region.current.name}.dynamodb\"\n  vpc_id          = aws_vpc.main.id\n  route_table_ids = compact(concat(aws_route_table.private.*.id, aws_route_table.public.*.id))\n  policy          = var.dynamodb_endpoint_policy\n  tags = merge(\n    var.tags,\n    {\n      \"Name\" = \"${var.name_prefix}-dynamodb\"\n    },\n  )\n}",
  "outputs": "# ------------------------------------------------------------------------------\n# Output\n# ------------------------------------------------------------------------------\noutput \"vpc_id\" {\n  description = \"The ID of the VPC.\"\n  value       = aws_vpc.main.id\n}\n\noutput \"cidr_block\" {\n  description = \"The cidr_block of the VPC.\"\n  value       = aws_vpc.main.cidr_block\n}\n\noutput \"public_subnet_ids\" {\n  description = \"The ID of the public subnets.\"\n  value       = aws_subnet.public[*].id\n}\n\noutput \"private_subnet_ids\" {\n  description = \"The ID of the private subnets.\"\n  value       = aws_subnet.private[*].id\n}\n\noutput \"main_route_table_id\" {\n  description = \"The ID of the main route table.\"\n  value       = aws_vpc.main.main_route_table_id\n}\n\noutput \"public_subnets_route_table_id\" {\n  description = \"The ID of the routing table for the public subnets.\"\n  value       = concat(aws_route_table.public[*].id, [\"\"])[0]\n}\n\noutput \"private_subnets_route_table_ids\" {\n  description = \"The IDs of the routing tables for the private subnets.\"\n  value       = aws_route_table.private[*].id\n}\n\noutput \"nat_gateway_ids\" {\n  description = \"The IDs of the NAT Gateways.\"\n  value       = aws_nat_gateway.private[*].id\n}\n\noutput \"default_security_group_id\" {\n  description = \"The id of the VPC default security group\"\n  value       = aws_vpc.main.default_security_group_id\n}\n\noutput \"default_network_acl_id\" {\n  description = \"The ID of the network ACL created by default on VPC creation\"\n  value       = aws_vpc.main.default_network_acl_id\n}",
  "variables": "# ------------------------------------------------------------------------------\n# Variables\n# ------------------------------------------------------------------------------\nvariable \"region\" {\n  type    = string\n  default = \"eu-west-1\"\n}\nvariable \"name_prefix\" {\n  description = \"A prefix used for naming resources.\"\n  type        = string\n}\n\nvariable \"cidr_block\" {\n  description = \"The CIDR block for the VPC.\"\n  type        = string\n}\n\nvariable \"availability_zones\" {\n  description = \"The availability zones to use for subnets and resources in the VPC. By default, all AZs in the region will be used.\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"public_subnet_cidrs\" {\n  description = \"A list of CIDR blocks to use for the public subnets.\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"private_subnet_cidrs\" {\n  description = \"A list of CIDR blocks to use for the private subnets.\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"ipv6_public_subnet_netnum_offset\" {\n  description = \"By default public IPv6 subnets is allocated from start of VPC IPv6 CIDR block. This can be used to force an offset, i.e. if adding public subnets when private ones already exists (which would be at beginning of block).\"\n  type        = number\n  default     = 0\n}\n\nvariable \"ipv6_private_subnet_netnum_offset\" {\n  description = \"By default private IPv6 subnet is allocated directly after last public subnet. This can be used to force an offset.\"\n  type        = number\n  default     = -1\n}\n\nvariable \"map_public_ip_on_launch\" {\n  description = \"Specify true to indicate that instances launched into the subnet should be assigned a public IP address. Default is true.\"\n  type        = bool\n  default     = true\n}\n\nvariable \"create_nat_gateways\" {\n  description = \"Optionally create NAT gateways (which cost $) to provide internet connectivity to the private subnets.\"\n  type        = bool\n  default     = true\n}\n\nvariable \"create_internet_gateway\" {\n  description = \"Optionaly create an Internet Gateway resource\"\n  type        = bool\n  default     = true\n}\n\nvariable \"create_egress_only_internet_gateway\" {\n  description = \"Optionaly create an Egress Only Internet Gateway resource\"\n  type        = bool\n  default     = true\n}\n\nvariable \"enable_dns_hostnames\" {\n  description = \"A boolean flag to enable/disable DNS hostnames in the VPC.\"\n  type        = bool\n  default     = false\n}\n\nvariable \"tags\" {\n  description = \"A map of tags (key-value pairs) passed to resources.\"\n  type        = map(string)\n  default     = {}\n}\n\nvariable \"s3_endpoint_policy\" {\n  description = \"Policy document to attach to S3 Gateway Endpoint. Defaults to blank.\"\n  default     = null\n}\n\nvariable \"dynamodb_endpoint_policy\" {\n  description = \"Policy document to attach to DynamoDb Gateway Endpoint. Defaults to blank.\"\n  default     = null\n}\n\nvariable \"enable_vpc_endpoints\" {\n  description = \"Enable or disable VPC endpoints\"\n  default     = true\n}",
  "aws-provider": "terraform {\n  required_providers {\n    aws = {\n      version = \"~> 4.0\"\n      source  = \"hashicorp/aws\"\n    }\n  }\n  required_version = \">= 1.1.3\"\n}\n\nprovider \"aws\" {\n  region = var.region\n  shared_credentials_files = [\"~/.aws/creds\"]\n}"
}